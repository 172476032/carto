diff --git a/lib/carto/tree/definition.js b/lib/carto/tree/definition.js
index 1408887..e0763e1 100644
--- a/lib/carto/tree/definition.js
+++ b/lib/carto/tree/definition.js
@@ -70,10 +70,12 @@ tree.Definition.prototype.appliesTo = function(id, classes) {
     return true;
 };
 
-function symbolizerName(symbolizer) {
+function tagName(name, type) {
     function capitalize(str) { return str[1].toUpperCase(); }
-    return symbolizer.charAt(0).toUpperCase() +
-           symbolizer.slice(1).replace(/\-./, capitalize) + 'Symbolizer';
+    return name.charAt(0).toUpperCase() +
+           name.slice(1).replace(/\-./, capitalize) +
+           type.charAt(0).toUpperCase() +
+           type.slice(1).replace(/\-./, capitalize);
 }
 
 // Get a simple list of the symbolizers, in order
@@ -82,8 +84,27 @@ function symbolizerList(sym_order) {
         .map(function(v) { return v[0]; });
 }
 
-tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
-    var xml = zoom.toXML(env).join('') + this.filters.toXML(env);
+tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom,
+                                                      ruleType) {
+    var xml = '';
+    if (!ruleType) {
+        xml += zoom.toXML(env).join('') + this.filters.toXML(env);
+    }
+    
+    var group_key;
+    var grouped_symbolizers = {};
+    for (var key in symbolizers) {
+        if (key.split('/').pop() === 'group') {
+            group_key = key;
+        } else {
+            grouped_symbolizers[key] = symbolizers[key];
+        }
+    }
+    if (group_key) {
+        var group_symbolizer = symbolizers[group_key];
+        symbolizers = {};
+        symbolizers[group_key] = group_symbolizer;
+    }
 
     // Sort symbolizers by the index of their first property definition
     var sym_order = [], indexes = [];
@@ -118,7 +139,7 @@ tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
             });
         }
 
-        var name = symbolizerName(symbolizer);
+        var name = tagName(symbolizer, "symbolizer");
 
         var selfclosing = true, tagcontent;
         xml += '    <' + name + ' ';
@@ -139,7 +160,14 @@ tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
                 xml += attributes[j].ev(env).toXML(env) + ' ';
             }
         }
-        if (selfclosing) {
+        if (symbolizer === 'group') {
+            xml += '>\n';
+            xml += '      <SimpleLayout />\n';
+            xml += this.symbolizersToXML(env, grouped_symbolizers, zoom,
+                                         'group').replace(/^/gm, '    ');
+            xml += '</' + name + '>\n';
+            break;
+        } else if (selfclosing) {
             xml += '/>\n';
         } else if (typeof tagcontent !== "undefined") {
             if (tagcontent.indexOf('<') != -1) {
@@ -150,7 +178,8 @@ tree.Definition.prototype.symbolizersToXML = function(env, symbolizers, zoom) {
         }
     }
     if (!sym_count || !xml) return '';
-    return '  <Rule>\n' + xml + '  </Rule>\n';
+    var ruleName = tagName(ruleType || '', "rule");
+    return '  <' + ruleName + '>\n' + xml + '  </' + ruleName + '>\n';
 };
 
 // Take a zoom range of zooms and 'i', the index of a rule in this.rules,
